name: Qt Project CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# 【修改点 1】增加 permissions 配置，确保有读取代码的权限
permissions:
  contents: read

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
    # 【修改点 2】优化 checkout 步骤，防止 128 错误
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0          # 拉取完整的 git 历史，防止浅克隆导致的引用错误
        submodules: recursive   # 如果项目里有子模块，必须加上这一行
        token: ${{ secrets.GITHUB_TOKEN }} # 显式使用 Token

    - name: Install Qt Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y qtbase5-dev qt5-qmake qtbase5-dev-tools \
                                libqt5sql5-sqlite build-essential \
                                xvfb pkg-config

    - name: Compile Project
      run: |
        echo "正在编译项目..."
        # 确保这里的文件列表包含了你所有的 .cpp 文件
        # 如果你有 .ui 文件，需要确保 main.cpp 里包含了生成的头文件，或者使用 cmake/qmake 构建
        # 这里为了稳妥，我们使用 qmake 自动生成项目文件来构建，比手动 g++ 更安全
        
        # 1. 初始化项目文件 (如果没有 .pro)
        if [ ! -f *.pro ]; then
          qmake -project "QT += core gui sql widgets" "CONFIG += console"
        fi
        
        # 2. 生成 Makefile
        qmake
        
        # 3. 编译
        make
        
        echo "编译完成"

    - name: Run Tests
      run: |
        # 自动查找生成的可执行文件（通常与目录同名）
        # 如果是 qmake -project 生成的，可执行文件名通常是仓库名的全小写
        # 这里我们尝试找到最新生成的可执行文件
        
        EXE_FILE=$(find . -maxdepth 1 -type f -executable -not -name "*.*" | head -n 1)
        
        if [ -z "$EXE_FILE" ]; then
           echo "❌ 错误：未找到可执行文件，编译可能失败了。"
           exit 1
        fi
        
        echo "找到可执行文件: $EXE_FILE"
        
        # 创建一个临时的测试脚本
        echo "#!/bin/bash" > run_check.sh
        echo "timeout 5s $EXE_FILE" >> run_check.sh
        chmod +x run_check.sh
        
        # 使用 xvfb 运行
        xvfb-run --auto-servernum ./run_check.sh || if [ $? -eq 124 ]; then echo "✅ 测试通过 (程序运行正常)"; else exit 1; fi
